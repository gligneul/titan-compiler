#!/usr/bin/env titan

local argparse = require 'argparse'

local checker = require 'titan-compiler.checker'
local coder = require 'titan-compiler.coder'
local parser = require 'titan-compiler.parser'
local util = require 'titan-compiler.util'
local pretty = require 'titan-compiler.pretty'

local p = argparse('titan', 'Titan compiler')
p:argument('input', 'Input file.')
p:option("-m --modname", 'Module name (defaults to input file stripped of ".titan" extension and with path characters replaced by ".".')
p:flag('--print-ast', 'Print the AST.')
p:flag('--print-types', 'Print the AST with types.')
p:option('-l --lua', 'Path to Lua source tree.')
local args = p:parse()

-- Work like assert, but don't print the stack trace
local function exit(msg)
    io.stderr:write(arg[0], ": ", msg, "\n")
    os.exit(1)
end

local modname

local input, err
input, errmsg = util.get_file_contents(args.input)
if not input then exit(errmsg) end

args.output = args.input:gsub("[.]titan$", ".c")
args.header = args.input:gsub("[.]titan$", ".h")

if not args.modname then
    args.modname = args.input:match("(.*)[.]titan$"):gsub("[/\\]", ".")
end

if not args.lua then
    args.lua = "lua/src/"
end

local ast, err = parser.parse(input)
if not ast then exit(parser.error_to_string(err, args.input)) end

if args.print_ast then
  print(parser.pretty_print_ast(ast))
  os.exit(0)
end

local ok, errmsgs = checker.check(args.modname, ast, input, args.input)
if errmsgs then exit(errmsgs) end

if args.print_types then
    print(parser.pretty_print_ast(ast))
    os.exit(0)
end

local function getpath(fname)
    return fname:match("^(.*)[/\\]") or "."
end

local function mods2so(mods)
    local sos = {}
    for _, modname in ipairs(mods) do
        table.insert(sos, checker.imported[modname].filename:gsub("[.]titan$", "") .. ".so")
    end
    return sos
end

local generated_code, deps = coder.generate(args.modname, ast)
generated_code = pretty.reindent_c(generated_code)
ok, errmsg = util.set_file_contents(args.output, generated_code)
if not ok then exit(errmsg) end

local CC = os.getenv("CC") or "gcc"
local CFLAGS = os.getenv("CFLAGS") or "--std=c99 -O2 -Wall"

local function compile_module(name)
    if not checker.imported[name].compiled then
        local mod = checker.imported[name]
        local code, deps = coder.generate(name, mod.ast)
        code = pretty.reindent_c(code)
        local filename = mod.filename:gsub("[.]titan$", "") .. ".c"
        local ok, err = util.set_file_contents(filename, code)
        if not ok then return exit(err) end
        for i = 1, #deps do
            compile_module(deps[i])
            deps[i] = mods2so(deps[i])
        end
        local soname = filename:gsub("[.]c$", ".so")
        local cc_cmd = string.format([[
            %s %s -I%s -fPIC -shared %s %s -o %s
            ]], CC, CFLAGS, args.lua, filename, table.concat(deps, " "), soname)
        --print(cc_cmd)
        local ok, err = os.execute(cc_cmd)
        if not ok then return exit(err) end
        checker.imported[name].compiled = true
    end
end

for name, _ in pairs(checker.imported) do
    if name ~= args.modname then
        compile_module(name)
    end
end

local soname = args.output:gsub("[.]c$", ".so")
os.execute(string.format([[
%s %s -I%s -fPIC -shared %s %s -o %s
]], CC, CFLAGS, args.lua, args.output, table.concat(mods2so(deps), " "), soname))
